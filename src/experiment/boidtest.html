<!DOCTYPE HTML>
<html>
<head>
	<title>Alpha Site Unit Flocking Tester</title>
	<style type="text/css">

html, body { margin : 0; padding : 0; }

	</style>
	<script src="../engine/util.js"></script>
	<script src="../engine/ooputil.js"></script>
	<script src="../engine/mathutil.js"></script>
	<script src="../engine/htmlutil.js"></script>
	<script type="text/javascript">

var fieldWidth = 0;
var fieldHeight = 0;

var boids = [];

var creationCounter = 0;

/*
var options = {
	'visualDistance': 20,
	'collisionDistance': 10,
	'avoidDistance': 20,
	'separationDistance': 15,
	'goalReachedDistance': 20,
	'lookAheadTicks': 40,
	'speed': 2,
	'rotationSpeed': Math.PI / 10,
	'size': 5
};
//*/

///*
// Slower, more tank-like behavior
var options = {
	'visualDistance': 40,
	'collisionDistance': 13,
	'avoidDistance': 15,
	'separationDistance': 20,
	'goalReachedDistance': 20,
	'lookAheadTicks': 80,
	'speed': 0.5,
	'rotationSpeed': Math.PI / 80,
	'size': 5
};
//*/

var groupColors = [
	'#000',
	'#900',
	'#090',
	'#009'
];

var STEERING_METHODS = {
	'STATIONARY': 0,
	'HARD_COLLISION': 1,
	'AVOID_COLLISION': 2,
	'SEEK_GOAL': 3,
	'SEPARATION': 4,
	'AVOID_PLOW': 5
};

var METHOD_COLORS = [
	'#ff0',
	'#f00',
	'#0f0',
	'#009',
	'#090',
	'#099'
];

function getMode() {
	var elm = document.getElementById('mode');
	return elm.options[elm.selectedIndex].value;
}

function getGroup() {
	var elm = document.getElementById('group');
	return elm.selectedIndex + 1;
}

function getCount() {
	var elm = document.getElementById('count');
	return parseInt(elm.options[elm.selectedIndex].value);
}

function scale(dx, dy, speed) {
	if (dx == 0 && dy == 0) {
		return [0, 0];
	}
	var rad = Math.atan2(dy, dx);
	return [speed * Math.cos(rad), speed * Math.sin(rad)];
}

function subtract(a, b) {
	return {'x': a.x - b.x, 'y': a.y - b.y};
}

function dot(a, b) {
	return a.x * b.x + a.y * b.y;
}

function distance(a, b) {
	var dx = a.x - b.x;
	var dy = a.y - b.y;
	return Math.sqrt(dx * dx + dy * dy);
}

// Returns the shortest distance between two line segments (p1, p2), (p3, p4),
// and points on the nearest approach, or null if there is no solution.
// Adapted from http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline3d/
function lineSegmentDistance(p1, p2, p3, p4) {
	var EPS = 0.0000001;

	var p13 = {'x': p1.x - p3.x, 'y': p1.y - p3.y};
	var p43 = {'x': p4.x - p3.x, 'y': p4.y - p3.y};
	if (Math.abs(p43.x) < EPS && Math.abs(p43.y) < EPS) {
		return null;
	}

	var p21 = {'x': p2.x - p1.x, 'y': p2.y - p1.y};
	if (Math.abs(p21.x) < EPS && Math.abs(p21.y) < EPS) {
		return null;
	}

	var d1343 = p13.x * p43.x + p13.y * p43.y;
	var d4321 = p43.x * p21.x + p43.y * p21.y;
	var d1321 = p13.x * p21.x + p13.y * p21.y;
	var d4343 = p43.x * p43.x + p43.y * p43.y;
	var d2121 = p21.x * p21.x + p21.y * p21.y;

	var denom = d2121 * d4343 - d4321 * d4321;
	if (Math.abs(denom) < EPS) {
		return null;
	}
	var numer = d1343 * d4321 - d1321 * d4343;

	var mua = numer / denom;
	var mub = (d1343 + d4321 * mua) / d4343;

	if (mua < 0 || mub < 0) {
		return;
	}

	var result = {};

	if (mua > 1) {
		result.a = {'x': p2.x, 'y': p2.y};
	} else {
		result.a = {'x': p1.x + mua * p21.x, 'y': p1.y + mua * p21.y};
	}

	if (mub > 1) {
		result.b = {'x': p4.x, 'y': p4.y};
	} else {
		result.b = {'x': p3.x + mub * p43.x, 'y': p3.y + mub * p43.y};
	}

	result.d = Math.sqrt(
		Math.pow(result.a.x - result.b.x, 2) +
		Math.pow(result.a.y - result.b.y, 2)
	);

	return result;
}

// Returns the shortest distance between two points p1, p2, travelling
// distance v1, v2, and when the nearest approach occurs, or null if will not be
// any collision.
// See http://www.flipcode.com/archives/Theory_Practice-Issue_01_Collision_Detection.shtml
function nearestApproach(p1, v1, p2, v2) {
	// t_1 = -(ax + by) / (a^2 + b^2)
	// where a is the X component of the relative velocity of p2
	//       b is the Y component of the relative velocity of p2
	//       x is the X component of the relative location of p2
	//       y is the Y component of the relative location of p2

	var a = v2.x - v1.x;
	var b = v2.y - v1.y;
	var x = p2.x - p1.x;
	var y = p2.y - p1.y;

	var denom = (a * a + b * b);
	if (denom === 0) {
		return null;
	}
	var t = -(a * x + b * y) / denom;

	if (t < 0 || t > 1) {
		return null;
	}

	return {
		'a': {'x': p1.x + v1.x * t, 'y': p1.y + v1.y * t},
		'b': {'x': p2.x + v2.x * t, 'y': p2.y + v2.y * t},
		't': t
	};
}

// Returns the first collision between two circles p1, p2, travelling distances
// v1, v2 at uniform speed, when the combined radii are r. Returns null if there
// will not be such collision.
// See http://www.flipcode.com/archives/Theory_Practice-Issue_01_Collision_Detection.shtml
function firstCollision(p1, v1, p2, v2, r) {
	// (x + a*t)^2 + (y + b*t)^2 = r^2
	// Where x = p1.x - p2.x
	//       y = p1.y - p2.y
	//       a = v1.x - v2.x
	//       b = v1.y - v2.y
	// Solved for t
	// http://www.wolframalpha.com/input/?i=%28x+%2B+a*t%29^2+%2B+%28y+%2B+b*t%29^2+%3D+r^2+solve+for+t

	var x = p1.x - p2.x;
	var y = p1.y - p2.y;
	var a = v1.x - v2.x;
	var b = v1.y - v2.y;

	var denom = (a*a + b*b);
	if (denom === 0) {
		return null;
	}

	var numera = Math.sqrt(a*a*r*r + b*b*r*r - b*b*x*x + 2*a*b*x*y - a*a*y*y);
	var numerb = -a*x - b*y;

	var roota = (-numera + numerb) / denom;
	var rootb = (numera + numerb) / denom;

	var t = 1;
	var success = false;
	if (roota >= 0 && roota <= t) {
		t = roota;
		success = true;
	}
	if (rootb >= 0 && rootb <= t) {
		t = rootb;
		success = true;
	}

	if (!success) {
		return null;
	}

	return {
		'a': {'x': p1.x + v1.x * t, 'y': p1.y + v1.y * t},
		'b': {'x': p2.x + v2.x * t, 'y': p2.y + v2.y * t},
		't': t
	};
}

//////////
// Vec //
////////

function Vec(x, y) {
	this.x = x || 0;
	this.y = y || 0;
}

///////////
// Boid //
/////////

function Boid(x, y, group) {
	this.x = x;
	this.y = y;
	this.group = group;
	this.speed = options.speed;
	this.targetX = x;
	this.targetY = y;
	this.serialNo = creationCounter++;
};

Boid.prototype.setTarget = function (x, y) {
	this.targetX = x;
	this.targetY = y;
};

Boid.prototype.getMates = function () {
	var result = [];
	for (var i = 0; i < boids.length; ++i) {
		var boid = boids[i];
		var distanceSquared = Math.pow(Math.abs(this.x - boid.x), 2) + Math.pow(Math.abs(this.y - boid.y), 2);
		if (boid != this && distanceSquared <= Math.pow(options.visualDistance, 2)) {
			result.push([boid, Math.sqrt(distanceSquared)]);
		}
	}
	return result;
}

Boid.prototype.tick = function () {
	var dx = 0;
	var dy = 0;
	var mates = this.getMates();
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		// Separation
		if (mate[1] <= options.separationDistance) {
			dx += (this.x - mate[0].x) / options.separationDistance * 10;
			dy += (this.y - mate[0].y) / options.separationDistance * 10;
		}
	}
	// Goal seeking
	var goal = scale(this.targetX - this.x, this.targetY - this.y, 1);
	dx += goal[0];
	dy += goal[1];
	// Apply
	var res = scale(dx, dy, options.speed);
	this.x += res[0];
	this.y += res[1];
};

////////////
// Boid2 //
//////////

function Boid2(x, y, group) {
	Boid.call(this, x, y, group);
	this.goalReached = true;
	this.heading = 0;
	this.rotationSpeed = options.rotationSpeed;
};

Boid2.prototype.setTarget = function (x, y) {
	this.targetX = x;
	this.targetY = y;
	this.goalReached = false;
}

Boid2.prototype.getMates = Boid.prototype.getMates;

// See http://www.red3d.com/cwr/steer/gdc99/
Boid2.prototype.tick = function () {
	var dx = 0;
	var dy = 0;
	var mates = this.getMates();
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		// Separation
		if (mate[1] <= options.separationDistance && (!mate[0].goalReached || this.goalReached)) {
			dx += (this.x - mate[0].x) / options.separationDistance * 10;
			dy += (this.y - mate[0].y) / options.separationDistance * 10;
		}
		// Alignment
		/*if (mate[0].heading && !mate[0].goalReached) {
			dx += Math.cos(mate[0].heading);
			dy += Math.sin(mate[0].heading);
		}*/
	}
	// Goal seeking
	if (!this.goalReached) {
		if (Math.pow(this.targetX - this.x, 2) + Math.pow(this.targetY - this.y, 2)
			<= Math.pow(options.goalReachedDistance, 2))
		{
			this.goalReached = true
		} else {
			var goal = scale(this.targetX - this.x, this.targetY - this.y, 1);
			dx += goal[0];
			dy += goal[1];
		}
	}
	// Apply
	if (dx == 0 && dy == 0) {
		return;
	}
	var targetHeading = Math.atan2(dy, dx);
	var angleDelta = MathUtil.angleDelta(this.heading, targetHeading);
	if (Math.abs(angleDelta) > this.rotationSpeed) {
		this.heading = MathUtil.normalizeAngle(this.heading + angleDelta / Math.abs(angleDelta) * this.rotationSpeed);
	} else {
		this.heading = targetHeading;
	}
	this.x += this.speed * Math.cos(this.heading);
	this.y += this.speed * Math.sin(this.heading);
};

////////////
// Boid3 //
//////////

function Boid3(x, y, group) {
	Boid2.call(this, x, y, group);
};

Boid3.prototype.setTarget = Boid2.prototype.setTarget;

Boid3.prototype.getMates = Boid.prototype.getMates;

// See http://www.red3d.com/cwr/steer/gdc99/
Boid3.prototype.tick = function () {
	var sepX = 0;
	var sepY = 0;
	var alignX = 0;
	var alignY = 0;
	var mates = this.getMates();
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		// Separation
		if (mate[1] <= options.separationDistance && (!mate[0].goalReached || this.goalReached)) {
			/*
			sepX += (this.x - mate[0].x) / options.separationDistance;
			sepY += (this.y - mate[0].y) / options.separationDistance;
			//*/

			/*
			if (this.x > mate[0].x) {
				sepX += 1 - (this.x - mate[0].x) / options.separationDistance;
			} else {
				sepX -= 1 - (mate[0].x - this.x) / options.separationDistance;
			}
			if (this.y > mate[0].y) {
				sepY += 1 - (this.y - mate[0].y) / options.separationDistance;
			} else {
				sepY -= 1 - (mate[0].y - this.y) / options.separationDistance;
			}
			//*/

			/*
			if (this.x > mate[0].x) {
				sepX += 1 / ((this.x - mate[0].x) / options.separationDistance) - 1;
			} else {
				sepX -= 1 / ((mate[0].x - this.x) / options.separationDistance) - 1;
			}
			if (this.y > mate[0].y) {
				sepY += 1 / ((this.y - mate[0].y) / options.separationDistance) - 1;
			} else {
				sepY -= 1 / ((mate[0].y - this.y) / options.separationDistance) - 1;
			}
			//*/

			///*
			var sepThis = scale(this.x - mate[0].x, this.y - mate[0].y, 1);
			sepX += sepThis[0];
			sepY += sepThis[1];
			//*/
		}
		// Alignment
		/*if (mate[0].heading && !mate[0].goalReached) {
			alignX += Math.cos(mate[0].heading);
			alignY += Math.sin(mate[0].heading);
		}*/
	}
	// Goal seeking
	var goalX = 0;
	var goalY = 0;
	if (!this.goalReached) {
		if (Math.pow(this.targetX - this.x, 2) + Math.pow(this.targetY - this.y, 2)
			<= Math.pow(options.goalReachedDistance, 2))
		{
			this.goalReached = true
		} else {
			goalX = this.targetX - this.x;
			goalY = this.targetY - this.y;
		}
	}
	// Apply components
	var separation = scale(sepX, sepY, 2);
	var alignment = scale(alignX, alignY, 1);
	var goal = scale(goalX, goalY, 1);
	var dx = separation[0] + alignment[0] + goal[0];
	var dy = separation[1] + alignment[1] + goal[1];
	// Apply combined
	if (dx == 0 && dy == 0) {
		return;
	}
	var targetHeading = Math.atan2(dy, dx);
	var angleDelta = MathUtil.angleDelta(this.heading, targetHeading);
	if (Math.abs(angleDelta) > this.rotationSpeed) {
		this.heading = MathUtil.normalizeAngle(this.heading + angleDelta / Math.abs(angleDelta) * this.rotationSpeed);
	} else {
		this.heading = targetHeading;
	}
	this.x += this.speed * Math.cos(this.heading);
	this.y += this.speed * Math.sin(this.heading);
};

////////////
// Boid4 //
//////////

// Warning: doesn't really work

function Boid4(x, y, group) {
	Boid2.call(this, x, y, group);
};

Boid4.prototype.setTarget = Boid2.prototype.setTarget;

Boid4.prototype.getMates = Boid.prototype.getMates;

Boid4.prototype.tick = function () {
	var whiskers = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
	var goalBias = [0, 2, 2, 10, 10, 15, 15, 20, 20, 20, 15, 15, 10, 10, 2, 2];
	var mateBias = [10, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5];
	//*
	var whiskers = [1,  1, 1,  1,  1,  1,  1,  1];
	var goalBias = [0,  2, 10, 15, 20, 15, 10, 2];
	var mateBias = [20, 10, 0,  0,  0,  0,  0,  10];
	//*/
	var mates = this.getMates();
	var shouldMove = false;
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		// Separation
		if (mate[1] > 0 && mate[1] <= options.separationDistance && (!mate[0].goalReached || this.goalReached)) {
			var direction = Math.floor((Math.atan2(this.y - mate[0].y, this.x - mate[0].x) + Math.PI) / (Math.PI * 2 / whiskers.length));
			if (mate[1] <= 10) {
				whiskers[direction] = Infinity;
				shouldMove = true;
			} else {
				/*for (var j = 0; j < whiskers.length; ++j) {
					whiskers[(direction + j) % whiskers.length] += (options.separationDistance - mate[1]) * mateBias[j];
				}
				shouldMove = true;*/
			}
		}
	}
	// Goal seeking
	if (!this.goalReached || shouldMove) {
		if (Math.pow(this.targetX - this.x, 2) + Math.pow(this.targetY - this.y, 2)
			<= Math.pow(options.goalReachedDistance, 2)) {
			this.goalReached = true;
		} else {
			shouldMove = true;
			var direction = Math.floor((Math.atan2(this.y - this.targetY, this.x - this.targetX) + Math.PI) / (Math.PI * 2 / whiskers.length));
			for (var i = 1; i < whiskers.length; ++i) {
				whiskers[(direction + i) % whiskers.length] += goalBias[i];
			}
		}
	}
	// Find best direction
	if (!shouldMove) {
		return;
	}
	var bestDirection = -1;
	var bestValue = Infinity;
	for (var i = 0; i < whiskers.length; ++i) {
		if (whiskers[i] < bestValue) {
			bestValue = whiskers[i];
			bestDirection = i;
		}
	}
	// Orient towards best direction
	if (bestDirection < 0) {
		return;
	}
	var targetHeading = Math.PI * 2 / whiskers.length * (bestDirection + 0.5);
	/*var angleDelta = MathUtil.angleDelta(this.heading, targetHeading);
	if (Math.abs(angleDelta) > this.rotationSpeed) {
		this.heading = MathUtil.normalizeAngle(this.heading + angleDelta / Math.abs(angleDelta) * this.rotationSpeed);
	} else {
		this.heading = targetHeading;
	}*/
	this.heading = targetHeading;
	if (this.heading == targetHeading /*whiskers[Math.floor((this.heading + Math.PI) / (Math.PI * 2 / whiskers.length))] < Infinity*/) {
		this.x += this.speed * Math.cos(this.heading);
		this.y += this.speed * Math.sin(this.heading);
	}
};

////////////
// Boid5 //
//////////

function Boid5(x, y, group) {
	Boid2.call(this, x, y, group);
};

Boid5.prototype.setTarget = Boid2.prototype.setTarget;

Boid5.prototype.getMates = Boid.prototype.getMates;

// See http://www.red3d.com/cwr/steer/gdc99/
Boid5.prototype.tick = function () {
	var sepX = 0;
	var sepY = 0;
	var alignX = 0;
	var alignY = 0;
	var shouldMove = false;
	var mates = this.getMates();
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		// Separation
		if (mate[1] <= options.separationDistance && (!mate[0].goalReached || this.goalReached)) {
			var sepThis = scale(this.x - mate[0].x, this.y - mate[0].y, 1);
			sepX += sepThis[0];
			sepY += sepThis[1];
			shouldMove = true;
		}
		// Alignment
		/*if (mate[0].heading && !mate[0].goalReached) {
			alignX += Math.cos(mate[0].heading);
			alignY += Math.sin(mate[0].heading);
		}*/
	}
	// Goal seeking
	var goalX = 0;
	var goalY = 0;
	if (!this.goalReached || shouldMove) {
		if (Math.pow(this.targetX - this.x, 2) + Math.pow(this.targetY - this.y, 2)
				<= Math.pow(options.goalReachedDistance, 2)) {
			this.goalReached = true;
		} else {
			goalX = this.targetX - this.x;
			goalY = this.targetY - this.y;
			shouldMove = true;
		}
	}
	// Apply components
	var separation = scale(sepX, sepY, 2);
	var alignment = scale(alignX, alignY, 1);
	var goal = scale(goalX, goalY, 1);
	var dx = separation[0] + alignment[0] + goal[0];
	var dy = separation[1] + alignment[1] + goal[1];
	// Apply combined
	if (dx == 0 && dy == 0) {
		return;
	}
	var targetHeading = Math.atan2(dy, dx);
	var angleDelta = MathUtil.angleDelta(this.heading, targetHeading);
	if (Math.abs(angleDelta) > this.rotationSpeed) {
		this.heading = MathUtil.normalizeAngle(this.heading + angleDelta / Math.abs(angleDelta) * this.rotationSpeed);
	} else {
		this.heading = targetHeading;
	}
	var newX = this.x + this.speed * Math.cos(this.heading);
	var newY = this.y + this.speed * Math.sin(this.heading);
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		if (Math.pow(mate[0].x - this.x, 2) + Math.pow(mate[0].y - this.y, 2)
				<= Math.pow(options.collisionDistance, 2)) {
			var mateDirection = Math.atan2(mate[0].y - this.y, mate[0].x - this.x);
			if (Math.abs(MathUtil.angleDelta(this.heading, mateDirection)) <= Math.PI / 2) {
				return;
			}
		}
	}
	this.x = newX;
	this.y = newY;
};

////////////
// Boid6 //
//////////

function Boid6(x, y, group) {
	Boid2.call(this, x, y, group);
	this.method = 0;
	this.steer = null;
};

Boid6.init = function () {
	// Initialize the plowfield
	plowfieldShift = 5;   // 5: 32
	plowfieldSize = 1 << plowfieldShift;
	plowfieldWidth = fieldWidth >> plowfieldShift;
	plowfieldHeight = fieldHeight >> plowfieldShift;
	plowfield = [];
	for (var i = 0; i < plowfieldWidth * plowfieldHeight; ++i) {
		plowfield.push(new Vec(0, 0));
	}
};

Boid6.resetPlowfield = function () {
	for (var i = 0; i < plowfield.length; ++i) {
		var tile = plowfield[i];
		tile.x = 0;
		tile.y = 0;
	}
};

Boid6.extendPlowfield = function () {
	var newTiles = {};
	for (var y = 0; y < plowfieldHeight; ++y) {
		for (var x = 0; x < plowfieldWidth; ++x) {
			var tile = plowfield[y * plowfieldWidth + x];
			var newTile = null;
			if (tile.x == 0 && tile.y == 0) {
				for (var xd = -1; xd <= 1; ++xd) {
					for (var yd = -1; yd <= 1; ++yd) {
						if (xd || yd) {
							var tile2 = plowfield[(y + yd) * plowfieldWidth + x + xd];
							if (tile2 && (tile2.x || tile2.y)) {
								var scaled = scale(tile2.x, tile2.y, 1);
								var parallelness = scaled[0] * -xd + scaled[1] * -yd;
								var angle = 0.7;
								if (parallelness > angle) {
									if (!newTile) {
										newTile = new Vec(0, 0);
									}
									/*
									newTile.x -= Math.abs(tile2.x) * xd;
									newTile.y -= Math.abs(tile2.y) * yd;
									*/
									var scaling = (parallelness - angle) / (1 - angle);
									newTile.x += tile2.x * scaling;
									newTile.y += tile2.y * scaling;
								}
							}
						}
					}
				}
			}
			if (newTile) {
				newTiles[y * plowfieldWidth + x] = newTile;
			}
		}
	}
	for (var idx in newTiles) {
		plowfield[parseInt(idx)] = newTiles[idx];
	}
};

Boid6.tick = function () {
	this.resetPlowfield();
	for (var i = 0; i < boids.length; ++i) {
		var boid = boids[i];
		if (boid.group == 1) {
			boid.addToPlowfield();
		}
	}
	for (var i = 1; i <= 3; ++i) {
		this.extendPlowfield();
	}
	for (var i = 0; i < boids.length; ++i) {
		boids[i].tick();
	}
};

Boid6.drawPlowfield = function (ctx) {
	for (var i = 0; i < plowfield.length; ++i) {
		var tile = plowfield[i];
		if (tile.x != 0 || tile.y != 0) {
			var tileX = i % plowfieldWidth;
			var tileY = Math.floor(i / plowfieldWidth);
			var cornerX = tileX * plowfieldSize;
			var cornerY = tileY * plowfieldSize;
			var originX = cornerX + (plowfieldSize / 2);
			var originY = cornerY + (plowfieldSize / 2);
			ctx.beginPath();
			ctx.moveTo(originX, originY);
			ctx.lineTo(originX + tile.x * 10, originY + tile.y * 10);
			ctx.stroke();
			ctx.strokeRect(cornerX, cornerY, plowfieldSize, plowfieldSize);
		}
	}
};

Boid6.drawScreen = function (ctx) {
	this.drawPlowfield(ctx);
}

Boid6.prototype.setTarget = Boid2.prototype.setTarget;

Boid6.prototype.getMates = Boid.prototype.getMates;

Boid6.prototype.getLocation = function () {
	return {'x': this.x, 'y': this.y};
};

Boid6.prototype.getLookAheadTicks = function () {
	return this.goalReached ? options.lookAheadTicks / 2 : options.lookAheadTicks;
};

Boid6.prototype.getLookAheadVector = function (ticks) {
	if (this.goalReached) {
		return {'x': 0, 'y': 0};
	} else {
		return {
			'x': this.speed * ticks * Math.cos(this.heading),
			'y': this.speed * ticks * Math.sin(this.heading)
		};
	}
};

Boid6.prototype.getLookAheadPoint = function () {
	var vector = this.getLookAheadVector(this.getLookAheadTicks());
	return {'x': this.x + vector.x, 'y': this.y + vector.y};
};

Boid6.prototype.addToPlowfield = function () {
	// FIXME: Continuous splatting
	var tileX = this.x >> plowfieldShift;
	var tileY = this.y >> plowfieldShift;
	var tile = plowfield[tileY * plowfieldWidth + tileX];
	if (tile) {
		tile.x += Math.cos(this.heading);
		tile.y += Math.sin(this.heading);
	}
};

Boid6.prototype.steerFromHardCollision = function (mates) {
	var resX = 0;
	var resY = 0;
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		if (mate[1] <= options.collisionDistance) {
			resX += this.x - mate[0].x;
			resY += this.y - mate[0].y;
		}
	}
	if (resX || resY) {
		return [resX, resY];
	}
	return null;
};

Boid6.prototype.steerForSeparation = function (mates) {
	var resX = 0;
	var resY = 0;
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		if (mate[1] <= options.separationDistance && !mate[0].goalReached/* && mate[0].group <= this.group*/) {
			resX += this.x - mate[0].x;
			resY += this.y - mate[0].y;
		}
	}
	if (resX || resY) {
		return [resX, resY];
	}
	return null;
};

Boid6.prototype.steerToAvoidPlow = function () {
	if (this.group <= 1) {
		return;
	}
	// FIXME: Continuous sampling
	var tileX = this.x >> plowfieldShift;
	var tileY = this.y >> plowfieldShift;
	var tile = plowfield[tileY * plowfieldWidth + tileX];
	if (tile && (tile.x || tile.y)) {
		// Parallel: +1, perpendicular: 0, anti-parallel: -1
		var parallelness = Math.cos(this.heading) * tile.x + Math.sin(this.heading) * tile.y;
		var angle = 0.707;

		if (/*parallelness < -angle*/true) {
			// If anti-parallel to the field, steer perpendicular to the field's flow
			return [-tile.y, tile.x];
		}
	}
	return null;
};

Boid6.prototype.steerToAvoidCollisionThreat = function (threat, collision) {
	// Parallel: +1, perpendicular: 0, anti-parallel: -1
	var parallelness = Math.cos(this.heading) * Math.cos(threat.heading) +
			Math.sin(this.heading) * Math.sin(threat.heading);
	var angle = 0.707;

	// If a potential collision was found, compute steering to avoid
	var steer = 0;

	var side = {
		'x': -(Math.sin(this.heading)),
		'y': Math.cos(this.heading)
	};

	/*if (this.goalReached) {
		// If we have stopped, steer perpendicular to the threat's heading
		return [-Math.sin(threat.heading), Math.cos(threat.heading)];
	} else if (threat.goalReached) {
		// If the threat has stopped, steer away from the threat
		var offset = subtract(threat, this);
		steer = dot(offset, side) > 0 ? -1 : 1;
	} else*/ if (parallelness < -angle) {
		// Anti-parallel "head on" paths: steer away from future threat position
		var offset = subtract(collision.b, this);
		steer = dot(offset, side) > 0 ? -1 : 1;
	} else if (parallelness > angle) {
		// Parallel paths: steer away from threat
		var offset = subtract(threat, this);
		steer = dot(offset, side) > 0 ? -1 : 1;
	} else {
		// Perpendicular paths: steer behind threat
		if (threat.speed > this.speed || threat.serialNo > this.serialNo) {
			var threatVelocity = {
				'x': Math.cos(threat.heading),
				'y': Math.sin(threat.heading)
			};
			steer = dot(side, threatVelocity) > 0 ? -1 : 1;
		}
	}

	if (steer === 0) {
		return null;
	} else if (steer > 0) {
		return [side.x, side.y];
	} else {
		return [-side.x, -side.y];
	}
};

// Derived from the OpenSteer approach
Boid6.prototype.steerToAvoidCollision = function (mates) {
	var ticks = this.getLookAheadTicks();
	var collisions = [];
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		// Collision avoidance (threat finding phase)
		var potentialCollision = firstCollision(
			this.getLocation(),
			this.getLookAheadVector(ticks),
			mate[0].getLocation(),
			mate[0].getLookAheadVector(ticks),
			options.avoidDistance
		);
		if (potentialCollision) {
			potentialCollision.threat = mate[0];
			collisions.push(potentialCollision);
		}
	}

	if (collisions.length <= 0) {
		return null;
	}

	// Collision avoidance (steering phase)

	/*
	// Avoid earliest collision
	var minTime = 2;
	var collision = null;
	for (var i = 0; i < collisions.length; ++i) {
		if (collisions[i].t < minTime) {
			collision = collisions[i];
			minTime = collisions[i].t;
		}
	}
	return this.steerToAvoidCollisionThreat(collision.threat, collision);
	*/

	// Avoid all collisions
	var result = [0, 0];
	for (var i = 0; i < collisions.length; ++i) {
		var collision = collisions[i];
		var steer = this.steerToAvoidCollisionThreat(collision.threat, collision);
		if (steer) {
			result[0] += steer[0] * collision.t;
			result[1] += steer[1] * collision.t;
		}
	}
	return (result[0] != 0 || result[1] != 0) ? result : null;
};

Boid6.prototype.steerTowardsGoal = function () {
	if (!this.goalReached) {
		if (Math.pow(this.targetX - this.x, 2) + Math.pow(this.targetY - this.y, 2)
				<= Math.pow(options.goalReachedDistance, 2)) {
			this.goalReached = true;
		} else {
			return [this.targetX - this.x, this.targetY - this.y];
		}
	}
	return null;
};

Boid6.prototype.goalReachedDensity = function (mates) {
	var result = 0;
	for (var i = 0; i < mates.length; ++i) {
		if (mates[i][0].goalReached) {
			++result;
		}
	}
	return result;
};

// See http://www.red3d.com/cwr/steer/gdc99/
Boid6.prototype.tick = function () {
	var mates = this.getMates();
	var steer = null;
	if (!steer) {
		steer = this.steerFromHardCollision(mates);
		this.method = STEERING_METHODS.HARD_COLLISION;
	}
	if (!steer) {
		steer = this.steerForSeparation(mates);
		this.method = STEERING_METHODS.SEPARATION;
	}
	if (!steer) {
		steer = this.steerToAvoidPlow(mates);
		this.method = STEERING_METHODS.AVOID_PLOW;
	}
	/*
	if (!steer) {
		steer = this.steerToAvoidCollision(mates);
		this.method = STEERING_METHODS.AVOID_COLLISION;
	}
	*/
	if (!steer) {
		steer = this.steerTowardsGoal();
		this.method = STEERING_METHODS.SEEK_GOAL;
	}
	// Apply combined
	this.steer = steer;
	if (!steer) {
		this.method = STEERING_METHODS.STATIONARY;
		return;
	}
	var targetHeading = Math.atan2(steer[1], steer[0]);
	var angleDelta = MathUtil.angleDelta(this.heading, targetHeading);
	if (Math.abs(angleDelta) > this.rotationSpeed) {
		this.heading = MathUtil.normalizeAngle(this.heading + angleDelta / Math.abs(angleDelta) * this.rotationSpeed);
	} else {
		this.heading = targetHeading;
	}
	var newX = this.x + this.speed * Math.cos(this.heading);
	var newY = this.y + this.speed * Math.sin(this.heading);
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		if (Math.pow(mate[0].x - this.x, 2) + Math.pow(mate[0].y - this.y, 2)
				<= Math.pow(options.collisionDistance, 2)) {
			var mateDirection = Math.atan2(mate[0].y - this.y, mate[0].x - this.x);
			if (Math.abs(MathUtil.angleDelta(this.heading, mateDirection)) <= Math.PI / 2) {
				return;
			}
		}
	}
	this.x = newX;
	this.y = newY;
};

////////////////
// Main loop //
//////////////

function init() {
	var timeNode = document.getElementById('time').firstChild;
	var canvas = document.getElementById('screen');
	var ctx = canvas.getContext('2d');

	fieldWidth = parseInt(canvas.width);
	fieldHeight = parseInt(canvas.height);

	var boidType = Boid6;

	if (boidType.init) {
		boidType.init();
	}

	var initialSeparation = 40;

	boids.push(new boidType(100, 100, 1));
	boids.push(new boidType(100, 100 + initialSeparation, 1));
	boids.push(new boidType(100 + initialSeparation, 100, 1));
	boids.push(new boidType(100 + initialSeparation, 100 + initialSeparation, 1));
	boids.push(new boidType(100 + initialSeparation * 2, 100, 1));
	boids.push(new boidType(100 + initialSeparation * 2, 100 + initialSeparation, 1));
	boids.push(new boidType(100, 100 + initialSeparation * 2, 1));
	boids.push(new boidType(100 + initialSeparation, 100 + initialSeparation * 2, 1));

	var loopStarted = false;

	function drawScreen(paint, size) {
		ctx.save();
		if (!paint) {
			ctx.fillStyle = '#fff';
		}
		ctx.strokeStyle = '#00f';
		for (var i = 0; i < boids.length; ++i) {
			var boid = boids[i];
			ctx.save();
			if (paint) {
				ctx.fillStyle = groupColors[boid.group - 1];
			}
			ctx.translate(boid.x, boid.y);
			if (boid.heading) {
				ctx.rotate(boid.heading);
			}
			ctx.fillRect(-size, -size, size * 2 + 1, size * 2 + 1);
			ctx.restore();
			if (boid.steer) {
				ctx.save();
				if (boid.getLookAheadPoint) {
					var lap = boid.getLookAheadPoint();
					ctx.beginPath();
					ctx.moveTo(boid.x, boid.y);
					ctx.lineTo(lap.x, lap.y);
					ctx.stroke();
				}
				if (boid.method) {
					ctx.strokeStyle = METHOD_COLORS[boid.method];
					ctx.beginPath();
					ctx.moveTo(boid.x, boid.y);
					var scaledSteer = scale(boid.steer[0], boid.steer[1], 20);
					ctx.lineTo(boid.x + scaledSteer[0], boid.y + scaledSteer[1]);
					ctx.stroke();
				}
				ctx.restore();
			}
		}
		// Finally, draw any fields or additional information
		ctx.strokeStyle = '#0ff';
		if (boidType.drawScreen) {
			boidType.drawScreen(ctx);
		}
		ctx.restore();
	}

	function startLoop() {
		if (loopStarted) {
			return;
		}
		setInterval(function () {
			/*drawScreen(false, options.size + options.lookAheadTicks * options.speed * 1);*/
			ctx.clearRect(0, 0, fieldWidth, fieldHeight);
			var atStart = new Date();
			if (boidType.tick) {
				boidType.tick();
			} else {
				for (var i = 0; i < boids.length; ++i) {
					boids[i].tick();
				}
			}
			var atEnd = new Date();
			drawScreen(true, options.size);
			timeNode.nodeValue = 'Time : ' + (atEnd - atStart) + ' ms';
		}, 10);
		loopStarted = true;
	}

	canvas.addEventListener('click', function (evt) {
		var group = getGroup();
		switch (getMode()) {
			case 'move':
				for (var i = 0; i < boids.length; ++i) {
					if (boids[i].group == group) {
						boids[i].setTarget(evt.clientX, evt.clientY);
					}
				}
				break;
			case 'create':
				var count = getCount();
				for (var i = 0; i < count; ++i) {
					boids.push(new boidType(evt.clientX, evt.clientY + i * 5, group));
				}
				break;
			default:
				alert('Unknown mode');
		}
		startLoop();
	}, false);

	drawScreen(true, options.size);
}

window.addEventListener('load', init, false);

	</script>
</head>
<body>

<canvas id="screen" width="1000" height="1000"></canvas>

<div style="position : absolute; top : 20px; left : 920px;">

<p id="time">Time: ? ms</p>

<p>Mode:<br>
<select id="mode">
<option value="move">Move</option>
<option value="create">Create</option>
</select></p>

<p>Group:<br>
<select id="group">
<option value="1">1</option>
<option value="2">2</option>
<option value="3">3</option>
<option value="4">4</option>
</select></p>

<p>Count:<br>
<select id="count">
<option value="1">1</option>
<option value="2">2</option>
<option value="3">3</option>
<option value="4">4</option>
<option value="5">5</option>
<option value="6">6</option>
<option value="7">7</option>
<option value="8">8</option>
<option value="9">9</option>
<option value="10" selected>10</option>
</select></p>

</div>

</body>
</html>