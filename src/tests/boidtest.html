<!DOCTYPE HTML>
<html>
<head>
	<title>Firing Solution Unit Flocking Tester</title>
	<style type="text/css">

html, body { margin : 0; padding : 0; }

	</style>
	<script src="../engine/util.js"></script>
	<script src="../engine/ooputil.js"></script>
	<script src="../engine/mathutil.js"></script>
	<script src="../engine/htmlutil.js"></script>
	<script type="text/javascript">

var fieldWidth = 0;
var fieldHeight = 0;

var boids = [];

var creationCounter = 0;

/*
var options = {
	'visualDistance': 20,
	'collisionDistance': 10,
	'separationDistance': 15,
	'goalReachedDistance': 20,
	'lookAheadTicks': 40,
	'speed': 2,
	'rotationSpeed': Math.PI / 10,
	'size': 5
};
//*/

///*
// Slower, more tank-like behavior
var options = {
	'visualDistance': 20,
	'collisionDistance': 13,
	'separationDistance': 20,
	'goalReachedDistance': 20,
	'lookAheadTicks': 40,
	'speed': 0.5,
	'rotationSpeed': Math.PI / 80,
	'size': 5
};
//*/

var groupColors = [
	'#000',
	'#900',
	'#090',
	'#009'
];

var STEERING_METHODS = {
	'STATIONARY': 0,
	'HARD_COLLISION': 1,
	'AVOID_COLLISION': 2,
	'SEEK_GOAL': 3
};

var METHOD_COLORS = [
	'#ff0',
	'#f00',
	'#0f0',
	'#009'
];

function getMode() {
	var elm = document.getElementById('mode');
	return elm.options[elm.selectedIndex].value;
}

function getGroup() {
	var elm = document.getElementById('group');
	return elm.selectedIndex + 1;
}

function getCount() {
	var elm = document.getElementById('count');
	return parseInt(elm.options[elm.selectedIndex].value);
}

function scale(dx, dy, speed) {
	if (dx == 0 && dy == 0) {
		return [0, 0];
	}
	var rad = Math.atan2(dy, dx);
	return [speed * Math.cos(rad), speed * Math.sin(rad)];
}

function subtract(a, b) {
	return {'x': a.x - b.x, 'y': a.y - b.y};
}

function dot(a, b) {
	return a.x * b.x + a.y * b.y;
}

function distance(a, b) {
	var dx = a.x - b.x;
	var dy = a.y - b.y;
	return Math.sqrt(dx * dx + dy * dy);
}

// Returns the shortest distance between two line segments (p1, p2), (p3, p4),
// and points on the nearest approach, or null if there is no solution.
// Adapted from http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline3d/
function lineSegmentDistance(p1, p2, p3, p4) {
	var EPS = 0.0000001;

	var p13 = {'x': p1.x - p3.x, 'y': p1.y - p3.y};
	var p43 = {'x': p4.x - p3.x, 'y': p4.y - p3.y};
	if (Math.abs(p43.x) < EPS && Math.abs(p43.y) < EPS) {
		return null;
	}

	var p21 = {'x': p2.x - p1.x, 'y': p2.y - p1.y};
	if (Math.abs(p21.x) < EPS && Math.abs(p21.y) < EPS) {
		return null;
	}

	var d1343 = p13.x * p43.x + p13.y * p43.y;
	var d4321 = p43.x * p21.x + p43.y * p21.y;
	var d1321 = p13.x * p21.x + p13.y * p21.y;
	var d4343 = p43.x * p43.x + p43.y * p43.y;
	var d2121 = p21.x * p21.x + p21.y * p21.y;

	var denom = d2121 * d4343 - d4321 * d4321;
	if (Math.abs(denom) < EPS) {
		return null;
	}
	var numer = d1343 * d4321 - d1321 * d4343;

	var mua = numer / denom;
	var mub = (d1343 + d4321 * mua) / d4343;

	if (mua < 0 || mub < 0) {
		return;
	}

	var result = {};

	if (mua > 1) {
		result.a = {'x': p2.x, 'y': p2.y};
	} else {
		result.a = {'x': p1.x + mua * p21.x, 'y': p1.y + mua * p21.y};
	}

	if (mub > 1) {
		result.b = {'x': p4.x, 'y': p4.y};
	} else {
		result.b = {'x': p3.x + mub * p43.x, 'y': p3.y + mub * p43.y};
	}

	result.d = Math.sqrt(
		Math.pow(result.a.x - result.b.x, 2) +
		Math.pow(result.a.y - result.b.y, 2)
	);

	return result;
}


///////////
// Boid //
/////////

function Boid(x, y, group) {
	this.x = x;
	this.y = y;
	this.group = group;
	this.speed = options.speed;
	this.targetX = x;
	this.targetY = y;
	this.serialNo = creationCounter++;
};

Boid.prototype.setTarget = function (x, y) {
	this.targetX = x;
	this.targetY = y;
};

Boid.prototype.getMates = function () {
	var result = [];
	for (var i = 0; i < boids.length; ++i) {
		var boid = boids[i];
		var distanceSquared = Math.pow(Math.abs(this.x - boid.x), 2) + Math.pow(Math.abs(this.y - boid.y), 2);
		if (boid != this && distanceSquared <= Math.pow(options.visualDistance, 2)) {
			result.push([boid, Math.sqrt(distanceSquared)]);
		}
	}
	return result;
}

Boid.prototype.tick = function () {
	var dx = 0;
	var dy = 0;
	var mates = this.getMates();
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		// Separation
		if (mate[1] <= options.separationDistance) {
			dx += (this.x - mate[0].x) / options.separationDistance * 10;
			dy += (this.y - mate[0].y) / options.separationDistance * 10;
		}
	}
	// Goal seeking
	var goal = scale(this.targetX - this.x, this.targetY - this.y, 1);
	dx += goal[0];
	dy += goal[1];
	// Apply
	var res = scale(dx, dy, options.speed);
	this.x += res[0];
	this.y += res[1];
};

////////////
// Boid2 //
//////////

function Boid2(x, y, group) {
	Boid.call(this, x, y, group);
	this.goalReached = true;
	this.heading = 0;
	this.rotationSpeed = options.rotationSpeed;
};

Boid2.prototype.setTarget = function (x, y) {
	this.targetX = x;
	this.targetY = y;
	this.goalReached = false;
}

Boid2.prototype.getMates = Boid.prototype.getMates;

// See http://www.red3d.com/cwr/steer/gdc99/
Boid2.prototype.tick = function () {
	var dx = 0;
	var dy = 0;
	var mates = this.getMates();
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		// Separation
		if (mate[1] <= options.separationDistance && (!mate[0].goalReached || this.goalReached)) {
			dx += (this.x - mate[0].x) / options.separationDistance * 10;
			dy += (this.y - mate[0].y) / options.separationDistance * 10;
		}
		// Alignment
		/*if (mate[0].heading && !mate[0].goalReached) {
			dx += Math.cos(mate[0].heading);
			dy += Math.sin(mate[0].heading);
		}*/
	}
	// Goal seeking
	if (!this.goalReached) {
		if (Math.pow(this.targetX - this.x, 2) + Math.pow(this.targetY - this.y, 2)
			<= Math.pow(options.goalReachedDistance, 2))
		{
			this.goalReached = true
		} else {
			var goal = scale(this.targetX - this.x, this.targetY - this.y, 1);
			dx += goal[0];
			dy += goal[1];
		}
	}
	// Apply
	if (dx == 0 && dy == 0) {
		return;
	}
	var targetHeading = Math.atan2(dy, dx);
	var angleDelta = MathUtil.angleDelta(this.heading, targetHeading);
	if (Math.abs(angleDelta) > this.rotationSpeed) {
		this.heading = MathUtil.normalizeAngle(this.heading + angleDelta / Math.abs(angleDelta) * this.rotationSpeed);
	} else {
		this.heading = targetHeading;
	}
	this.x += this.speed * Math.cos(this.heading);
	this.y += this.speed * Math.sin(this.heading);
};

////////////
// Boid3 //
//////////

function Boid3(x, y, group) {
	Boid2.call(this, x, y, group);
};

Boid3.prototype.setTarget = Boid2.prototype.setTarget;

Boid3.prototype.getMates = Boid.prototype.getMates;

// See http://www.red3d.com/cwr/steer/gdc99/
Boid3.prototype.tick = function () {
	var sepX = 0;
	var sepY = 0;
	var alignX = 0;
	var alignY = 0;
	var mates = this.getMates();
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		// Separation
		if (mate[1] <= options.separationDistance && (!mate[0].goalReached || this.goalReached)) {
			/*
			sepX += (this.x - mate[0].x) / options.separationDistance;
			sepY += (this.y - mate[0].y) / options.separationDistance;
			//*/

			/*
			if (this.x > mate[0].x) {
				sepX += 1 - (this.x - mate[0].x) / options.separationDistance;
			} else {
				sepX -= 1 - (mate[0].x - this.x) / options.separationDistance;
			}
			if (this.y > mate[0].y) {
				sepY += 1 - (this.y - mate[0].y) / options.separationDistance;
			} else {
				sepY -= 1 - (mate[0].y - this.y) / options.separationDistance;
			}
			//*/

			/*
			if (this.x > mate[0].x) {
				sepX += 1 / ((this.x - mate[0].x) / options.separationDistance) - 1;
			} else {
				sepX -= 1 / ((mate[0].x - this.x) / options.separationDistance) - 1;
			}
			if (this.y > mate[0].y) {
				sepY += 1 / ((this.y - mate[0].y) / options.separationDistance) - 1;
			} else {
				sepY -= 1 / ((mate[0].y - this.y) / options.separationDistance) - 1;
			}
			//*/

			///*
			var sepThis = scale(this.x - mate[0].x, this.y - mate[0].y, 1);
			sepX += sepThis[0];
			sepY += sepThis[1];
			//*/
		}
		// Alignment
		/*if (mate[0].heading && !mate[0].goalReached) {
			alignX += Math.cos(mate[0].heading);
			alignY += Math.sin(mate[0].heading);
		}*/
	}
	// Goal seeking
	var goalX = 0;
	var goalY = 0;
	if (!this.goalReached) {
		if (Math.pow(this.targetX - this.x, 2) + Math.pow(this.targetY - this.y, 2)
			<= Math.pow(options.goalReachedDistance, 2))
		{
			this.goalReached = true
		} else {
			goalX = this.targetX - this.x;
			goalY = this.targetY - this.y;
		}
	}
	// Apply components
	var separation = scale(sepX, sepY, 2);
	var alignment = scale(alignX, alignY, 1);
	var goal = scale(goalX, goalY, 1);
	var dx = separation[0] + alignment[0] + goal[0];
	var dy = separation[1] + alignment[1] + goal[1];
	// Apply combined
	if (dx == 0 && dy == 0) {
		return;
	}
	var targetHeading = Math.atan2(dy, dx);
	var angleDelta = MathUtil.angleDelta(this.heading, targetHeading);
	if (Math.abs(angleDelta) > this.rotationSpeed) {
		this.heading = MathUtil.normalizeAngle(this.heading + angleDelta / Math.abs(angleDelta) * this.rotationSpeed);
	} else {
		this.heading = targetHeading;
	}
	this.x += this.speed * Math.cos(this.heading);
	this.y += this.speed * Math.sin(this.heading);
};

////////////
// Boid4 //
//////////

// Warning: doesn't really work

function Boid4(x, y, group) {
	Boid2.call(this, x, y, group);
};

Boid4.prototype.setTarget = Boid2.prototype.setTarget;

Boid4.prototype.getMates = Boid.prototype.getMates;

Boid4.prototype.tick = function () {
	var whiskers = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
	var goalBias = [0, 2, 2, 10, 10, 15, 15, 20, 20, 20, 15, 15, 10, 10, 2, 2];
	var mateBias = [10, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5];
	//*
	var whiskers = [1,  1, 1,  1,  1,  1,  1,  1];
	var goalBias = [0,  2, 10, 15, 20, 15, 10, 2];
	var mateBias = [20, 10, 0,  0,  0,  0,  0,  10];
	//*/
	var mates = this.getMates();
	var shouldMove = false;
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		// Separation
		if (mate[1] > 0 && mate[1] <= options.separationDistance && (!mate[0].goalReached || this.goalReached)) {
			var direction = Math.floor((Math.atan2(this.y - mate[0].y, this.x - mate[0].x) + Math.PI) / (Math.PI * 2 / whiskers.length));
			if (mate[1] <= 10) {
				whiskers[direction] = Infinity;
				shouldMove = true;
			} else {
				/*for (var j = 0; j < whiskers.length; ++j) {
					whiskers[(direction + j) % whiskers.length] += (options.separationDistance - mate[1]) * mateBias[j];
				}
				shouldMove = true;*/
			}
		}
	}
	// Goal seeking
	if (!this.goalReached || shouldMove) {
		if (Math.pow(this.targetX - this.x, 2) + Math.pow(this.targetY - this.y, 2)
			<= Math.pow(options.goalReachedDistance, 2)) {
			this.goalReached = true;
		} else {
			shouldMove = true;
			var direction = Math.floor((Math.atan2(this.y - this.targetY, this.x - this.targetX) + Math.PI) / (Math.PI * 2 / whiskers.length));
			for (var i = 1; i < whiskers.length; ++i) {
				whiskers[(direction + i) % whiskers.length] += goalBias[i];
			}
		}
	}
	// Find best direction
	if (!shouldMove) {
		return;
	}
	var bestDirection = -1;
	var bestValue = Infinity;
	for (var i = 0; i < whiskers.length; ++i) {
		if (whiskers[i] < bestValue) {
			bestValue = whiskers[i];
			bestDirection = i;
		}
	}
	// Orient towards best direction
	if (bestDirection < 0) {
		return;
	}
	var targetHeading = Math.PI * 2 / whiskers.length * (bestDirection + 0.5);
	/*var angleDelta = MathUtil.angleDelta(this.heading, targetHeading);
	if (Math.abs(angleDelta) > this.rotationSpeed) {
		this.heading = MathUtil.normalizeAngle(this.heading + angleDelta / Math.abs(angleDelta) * this.rotationSpeed);
	} else {
		this.heading = targetHeading;
	}*/
	this.heading = targetHeading;
	if (this.heading == targetHeading /*whiskers[Math.floor((this.heading + Math.PI) / (Math.PI * 2 / whiskers.length))] < Infinity*/) {
		this.x += this.speed * Math.cos(this.heading);
		this.y += this.speed * Math.sin(this.heading);
	}
};

////////////
// Boid5 //
//////////

function Boid5(x, y, group) {
	Boid2.call(this, x, y, group);
};

Boid5.prototype.setTarget = Boid2.prototype.setTarget;

Boid5.prototype.getMates = Boid.prototype.getMates;

// See http://www.red3d.com/cwr/steer/gdc99/
Boid5.prototype.tick = function () {
	var sepX = 0;
	var sepY = 0;
	var alignX = 0;
	var alignY = 0;
	var shouldMove = false;
	var mates = this.getMates();
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		// Separation
		if (mate[1] <= options.separationDistance && (!mate[0].goalReached || this.goalReached)) {
			var sepThis = scale(this.x - mate[0].x, this.y - mate[0].y, 1);
			sepX += sepThis[0];
			sepY += sepThis[1];
			shouldMove = true;
		}
		// Alignment
		/*if (mate[0].heading && !mate[0].goalReached) {
			alignX += Math.cos(mate[0].heading);
			alignY += Math.sin(mate[0].heading);
		}*/
	}
	// Goal seeking
	var goalX = 0;
	var goalY = 0;
	if (!this.goalReached || shouldMove) {
		if (Math.pow(this.targetX - this.x, 2) + Math.pow(this.targetY - this.y, 2)
				<= Math.pow(options.goalReachedDistance, 2)) {
			this.goalReached = true;
		} else {
			goalX = this.targetX - this.x;
			goalY = this.targetY - this.y;
			shouldMove = true;
		}
	}
	// Apply components
	var separation = scale(sepX, sepY, 2);
	var alignment = scale(alignX, alignY, 1);
	var goal = scale(goalX, goalY, 1);
	var dx = separation[0] + alignment[0] + goal[0];
	var dy = separation[1] + alignment[1] + goal[1];
	// Apply combined
	if (dx == 0 && dy == 0) {
		return;
	}
	var targetHeading = Math.atan2(dy, dx);
	var angleDelta = MathUtil.angleDelta(this.heading, targetHeading);
	if (Math.abs(angleDelta) > this.rotationSpeed) {
		this.heading = MathUtil.normalizeAngle(this.heading + angleDelta / Math.abs(angleDelta) * this.rotationSpeed);
	} else {
		this.heading = targetHeading;
	}
	var newX = this.x + this.speed * Math.cos(this.heading);
	var newY = this.y + this.speed * Math.sin(this.heading);
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		if (Math.pow(mate[0].x - this.x, 2) + Math.pow(mate[0].y - this.y, 2)
				<= Math.pow(options.collisionDistance, 2)) {
			var mateDirection = Math.atan2(mate[0].y - this.y, mate[0].x - this.x);
			if (Math.abs(MathUtil.angleDelta(this.heading, mateDirection)) <= Math.PI / 2) {
				return;
			}
		}
	}
	this.x = newX;
	this.y = newY;
};

////////////
// Boid6 //
//////////

function Boid6(x, y, group) {
	Boid2.call(this, x, y, group);
	this.method = 0;
	this.steer = null;
};

Boid6.prototype.setTarget = Boid2.prototype.setTarget;

Boid6.prototype.getMates = Boid.prototype.getMates;

Boid6.prototype.getLocation = function () {
	return {'x': this.x, 'y': this.y};
};

Boid6.prototype.getLookAheadPoint = function () {
	if (this.goalReached) {
		return {'x': this.x, 'y': this.y};
	} else {
		return {
			'x': this.x + this.speed * options.lookAheadTicks * Math.cos(this.heading),
			'y': this.y + this.speed * options.lookAheadTicks * Math.sin(this.heading)
		};
	}
};

Boid6.prototype.steerFromHardCollision = function (mates) {
	var resX = 0;
	var resY = 0;
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		if (mate[1] <= options.collisionDistance) {
			resX += this.x - mate[0].x;
			resY += this.y - mate[0].y;
		}
	}
	if (resX || resY) {
		return [resX, resY];
	}
	return null;
};

// Derived from the OpenSteer approach
Boid6.prototype.steerToAvoidCollision = function (mates) {
	var minDistance = Infinity;
	var threat = null;
	var collision = null;
	for (var i = 0; i < mates.length; ++i) {
		var mate = mates[i];
		// Collision avoidance (threat finding phase)
		var potentialCollision = lineSegmentDistance(this.getLocation(), this.getLookAheadPoint(), mate[0].getLocation(), mate[0].getLookAheadPoint());
		if (potentialCollision && potentialCollision.d <= options.collisionDistance) {
			var dist = distance(this, potentialCollision.a);
			if (dist < minDistance) {
				minDistance = dist;
				threat = mate[0];
				collision = potentialCollision;
			}
		}
	}

	if (!threat) {
		return null;
	}

	// Collision avoidance (steering phase)

	// Parallel: +1, perpendicular: 0, anti-parallel: -1
	var parallelness = Math.cos(this.heading) * Math.cos(threat.heading) +
			Math.sin(this.heading) * Math.sin(threat.heading);
	var angle = 0.707;

	// If a potential collision was found, compute steering to avoid
	var steer = 0;

	var side = {
		'x': -(Math.sin(this.heading)),
		'y': Math.cos(this.heading)
	};

	if (parallelness < -angle) {
		// Anti-parallel "head on" paths: steer away from future threat position
		var offset = subtract(collision.b, this);
		steer = dot(offset, side) > 0 ? -1 : 1;
	} else if (parallelness > angle) {
		// Parallel paths: steer away from threat
		var offset = subtract(threat, this);
		steer = dot(offset, side) > 0 ? -1 : 1;
	} else {
		// Perpendicular paths: steer behind threat (only the slower of two does
		// this).
		// FIXME: Does this make sense
		if (threat.speed <= this.speed) {
			var threatVelocity = {
				'x': Math.cos(threat.heading),
				'y': Math.sin(threat.heading)
			};
			steer = dot(side, threatVelocity) > 0 ? -1 : 1;
		}
	}

	if (steer === 0) {
		return null;
	} else if (steer > 0) {
		return [side.x, side.y];
	} else {
		return [-side.x, -side.y];
	}
};

Boid6.prototype.steerTowardsGoal = function () {
	if (!this.goalReached) {
		if (Math.pow(this.targetX - this.x, 2) + Math.pow(this.targetY - this.y, 2)
				<= Math.pow(options.goalReachedDistance, 2)) {
			this.goalReached = true;
		} else {
			return [this.targetX - this.x, this.targetY - this.y];
		}
	}
	return null;
};

// See http://www.red3d.com/cwr/steer/gdc99/
Boid6.prototype.tick = function () {
	var mates = this.getMates();
	var steer = null;
	if (!steer) {
		steer = this.steerFromHardCollision(mates);
		this.method = STEERING_METHODS.HARD_COLLISION;
	}
	if (!steer) {
		steer = this.steerToAvoidCollision(mates);
		this.method = STEERING_METHODS.AVOID_COLLISION;
	}
	if (!steer) {
		steer = this.steerTowardsGoal();
		this.method = STEERING_METHODS.SEEK_GOAL;
	}
	// Apply combined
	this.steer = steer;
	if (!steer) {
		this.method = STEERING_METHODS.STATIONARY;
		return;
	}
	var targetHeading = Math.atan2(steer[1], steer[0]);
	var angleDelta = MathUtil.angleDelta(this.heading, targetHeading);
	if (Math.abs(angleDelta) > this.rotationSpeed) {
		this.heading = MathUtil.normalizeAngle(this.heading + angleDelta / Math.abs(angleDelta) * this.rotationSpeed);
	} else {
		this.heading = targetHeading;
	}
	this.x = this.x + this.speed * Math.cos(this.heading);
	this.y = this.y + this.speed * Math.sin(this.heading);
};

////////////////
// Main loop //
//////////////

function init() {
	var timeNode = document.getElementById('time').firstChild;
	var canvas = document.getElementById('screen');
	var ctx = canvas.getContext('2d');

	fieldWidth = parseInt(canvas.width);
	fieldHeight = parseInt(canvas.height);

	var boidType = Boid6;

	boids.push(new boidType(100, 100, 1));
	boids.push(new boidType(100, 110, 1));
	boids.push(new boidType(110, 100, 1));
	boids.push(new boidType(110, 110, 1));
	boids.push(new boidType(120, 100, 1));
	boids.push(new boidType(120, 110, 1));
	boids.push(new boidType(100, 120, 1));
	boids.push(new boidType(110, 120, 1));

	var loopStarted = false;

	function drawScreen(paint, size) {
		ctx.save();
		if (!paint) {
			ctx.fillStyle = '#fff';
		}
		ctx.strokeStyle = '#00f';
		for (var i = 0; i < boids.length; ++i) {
			var boid = boids[i];
			ctx.save();
			if (paint) {
				ctx.fillStyle = groupColors[boid.group - 1];
			}
			ctx.translate(boid.x, boid.y);
			if (boid.heading) {
				ctx.rotate(boid.heading);
			}
			ctx.fillRect(-size, -size, size * 2 + 1, size * 2 + 1);
			ctx.restore();
			if (boid.steer) {
				ctx.save();
				if (boid.getLookAheadPoint) {
					var lap = boid.getLookAheadPoint();
					ctx.beginPath();
					ctx.moveTo(boid.x, boid.y);
					ctx.lineTo(lap.x, lap.y);
					ctx.stroke();
				}
				if (boid.method) {
					ctx.strokeStyle = METHOD_COLORS[boid.method];
					ctx.beginPath();
					ctx.moveTo(boid.x, boid.y);
					var scaledSteer = scale(boid.steer[0], boid.steer[1], 20);
					ctx.lineTo(boid.x + scaledSteer[0], boid.y + scaledSteer[1]);
					ctx.stroke();
				}
				ctx.restore();
			}
		}
		ctx.restore();
	}

	function startLoop() {
		if (loopStarted) {
			return;
		}
		setInterval(function () {
			drawScreen(false, options.size + options.lookAheadTicks * options.speed * 1);
			var atStart = new Date();
			for (var i = 0; i < boids.length; ++i) {
				boids[i].tick();
			}
			var atEnd = new Date();
			drawScreen(true, options.size);
			timeNode.nodeValue = 'Time : ' + (atEnd - atStart) + ' ms';
		}, 10);
		loopStarted = true;
	}

	canvas.addEventListener('click', function (evt) {
		var group = getGroup();
		switch (getMode()) {
			case 'move':
				for (var i = 0; i < boids.length; ++i) {
					if (boids[i].group == group) {
						boids[i].setTarget(evt.clientX, evt.clientY);
					}
				}
				break;
			case 'create':
				var count = getCount();
				for (var i = 0; i < count; ++i) {
					boids.push(new boidType(evt.clientX, evt.clientY + i * 5, group));
				}
				break;
			default:
				alert('Unknown mode');
		}
		startLoop();
	}, false);

	drawScreen(true, options.size);
}

window.addEventListener('load', init, false);

	</script>
</head>
<body>

<canvas id="screen" width="1000" height="1000"></canvas>

<div style="position : absolute; top : 20px; left : 920px;">

<p id="time">Time: ? ms</p>

<p>Mode:<br>
<select id="mode">
<option value="move">Move</option>
<option value="create">Create</option>
</select></p>

<p>Group:<br>
<select id="group">
<option value="1">1</option>
<option value="2">2</option>
<option value="3">3</option>
<option value="4">4</option>
</select></p>

<p>Count:<br>
<select id="count">
<option value="1">1</option>
<option value="2">2</option>
<option value="3">3</option>
<option value="4">4</option>
<option value="5">5</option>
<option value="6">6</option>
<option value="7">7</option>
<option value="8">8</option>
<option value="9">9</option>
<option value="10" selected>10</option>
</select></p>

</div>

</body>
</html>